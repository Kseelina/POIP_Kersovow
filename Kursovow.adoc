---
title: Курсовой
---
:reproducible:

:description: Kursovow
:keywords: AsciiDoc
:imagesdir: ImgKursovow
:figure-caption: Рисунок
:table-caption: Таблица


:toc-title: Содержание
:toc:

= Курсовой

[text-right]
--

--

== Глава 1. Анализ требований
Необходимо разработать устройство для охлаждения метрологического стенда.
Для этого сперва определим какие необходимы функции и переферия
для разрабатываемого устройства. +

=== АЦП с возможностью прямого доступа к памяти
Согласно заданию необходимо измерять температуру при помощи АЦП, при этом,
полученные данные с АЦП должны передаваться сразу в память устройства,
это обеспечивается при помощи DMA (контроллера прямого доступа к памяти).
В микроконтроллер STM32F411RE встроено 2 DMA каждый из которых является
8 поточным FIFO (по типу очереди, первый байт данных пришёл и первый же ушёл).
DMA поддерживает циклическое управление буфером,
т.е. пока половина буфера наполняется со второй (уже полностью заполненной)
можно производить какие-либо действия.

Каждый поток связан с запросом DMA, который можно выбрать из 8 возможных
запросов канала. Выбор управляется битами CHSEL[2:0] в DMA_SxCR регистр. +
Только DMA2 имеет возможность записывать с ADC1 данные в память и только
по каналу 0. Поэтому дальше будет опираться на ADC1 и DMA2.

.Канал 0
image::DMA_DMA2 и ADC1.png[]

.Расположение в памяти встроенных DMA
image::Область памяти DMA.png[]

.Подача тактирования на DMA по шине AHB1
image::Тактирование DMA2.png[]

Бит 22 DMA2EN: подача системного тактирования на DMA2

- 0: DMA2 выключить
- *1: DMA2 включить*

Помимо DMA также тактирование необходимо подать и АЦП.

.Подача тактирования на ADC по шине APB2
image::Тактирование на ADC.png[]

Бит 8 ADC1EN: Тактирование ADC1

- 0: ADC1 выключить
- *1: ADC1 включить*

Теперь займёмся настройками портов DMA и ADC.

Сперва дадим знать АЦП, что оно будет использовать DMA.

.Регистр управления ADC_CR2
image::ADC_CR2.png[]

Бит 30 SWSTART: Начать конвертацию обычных каналов

- 0: Сбросить состояние
- *1: Запускает конвертацию обычных каналов* +
Примечание.  +
Этот бит можно установить, только если ADON = 1, в противном случае
преобразование не запускается.

Бит 10 EOCS: Конец выбора конверсии

- 0: Бит EOC устанавливается в конце каждой последовательности обычных
преобразований. Обнаружение переполнения включается, только если DMA=1.
- *1: Бит EOC устанавливается в конце каждого обычного преобразования.
Обнаружение переполнения включено.*

Бит 9 DDS: Выбор отключения DMA (для режима одиночного АЦП)

- 0: После последней передачи не выдается новый запрос DMA
(как настроено в контроллере DMA)
- *1: Запросы DMA выдаются до тех пор, пока данные конвертируются и DMA=1.*

Запросы могут продолжать генерироваться, если бит DDS установлен в 1.
Это позволяет настроить DMA в циклическом режиме с двойным буфером.

Бит 8 DMA: Режим прямого доступа к памяти (для режима одиночного АЦП)

- 0: режим DMA выключен
- 1: *режим DMA включен*

Бит 1 CONT: Непрерывное преобразование
Этот бит устанавливается и сбрасывается программно.
Если он установлен, преобразование происходит непрерывно, пока не будет очищен.

- 0: Одиночный режим преобразования
- *1: Непрерывный режим преобразования*

Бит 0 ADON: Аналого-цифровой преобразователь ВКЛ./ВЫКЛ.

- 0: Отключение преобразования АЦП и переход в режим отключения питания.
- *1: Включить АЦП*

Теперь настроим канал DMA.
Выше было показано, что ADC1 может использоваться на 0 канале. Но т.к. данный
регистр настраивается только при сброшенном EN, то сперва необходимо установить
EN = 0, а затем уже настраивать каналы.

.Регистр конфигурации потока DMA DMA_SxCR
image::DMA_SxCR.png[]

Биты 27:25 CHSEL[2:0]: Выбор канала.

- *000: канал 0*
- 001: канал 1
- 010: канал 2
- 011: канал 3
- 100: канал 4
- 101: канал 5
- 110: канал 6
- 111: канал 7

Эти биты защищены и могут быть записаны, только если EN равен «0».

Бит 18 DBM: Двойной буферный режим

- 0: Нет переключения буфера в конце передачи
- *1: Целевой объект памяти переключается в конце передачи DMA* +
Этот бит защищен и может быть записан, только если EN равен «0».

Биты 14:13 MSIZE[1:0]: Размер данных памяти
Отвечает за то, куда будут сыпаться данные.
Т.к. процессор у нас 32-разрядный, то можно выделить 32 бита.

- 00: byte (8-bit)
- 01: half-word (16-bit)
- *10: word (32-bit)*
- 11: reserved

Эти биты защищены и могут быть записаны, только если EN равен «0».
В прямом режиме MSIZE принудительно устанавливается аппаратно на то же значение,
что и PSIZE, как только бит EN = «1».

Биты 12:11 PSIZE[1:0]: Размер периферийных данных
Т.к. АЦП у нас 12-разрядный, то выберем большее ближайшее.

- 00: Byte (8-bit)
- *01: Half-word (16-bit)*
- 10: Word (32-bit)
- 11: reserved

Эти биты защищены и могут быть записаны, только если EN равен «0».

Бит 8 CIRC: Циклический режим
Этот бит устанавливается и сбрасывается программно и может быть сброшен аппаратно.

- 0: disabled
- *1: enabled*

Когда периферийное устройство является контроллером потока (бит PFCTRL = 1) и
поток включен (бит EN = 1), то этот бит аппаратно автоматически устанавливается
в 0. Он автоматически устанавливается аппаратно в 1, если бит DBM установлен,
как только поток включено (бит EN = 1).

Биты 7:6 DIR[1:0]: Направление передачи данных
Эти биты устанавливаются и очищаются программным обеспечением.

- *00: Из периферийного устройства в память*
- 01: Из памяти в периферию
- 10: Из памяти в память
- 11: Зарезервировано

Эти биты защищены и могут быть записаны, только если EN равен «0».

Бит 5 PFCTRL: Контроллер периферийного потока
Этот бит устанавливается и сбрасывается программно.

- 0: *DMA — это контроллер потока*
- 1: Периферийное устройство — это контроллер потока

Этот бит защищен и может быть записан, только если EN равен «0».
Когда выбран режим памяти в память (биты DIR[1:0]=10), этот бит
автоматически сбрасывается на 0 аппаратно.

Бит 0 EN: Включить поток / пометить поток как готовый при низком уровне чтения
Этот бит устанавливается и сбрасывается программно.

- 0:  disabled
- *1:  enabled*

Когда этот бит считывается как 0, программе разрешено программировать
конфигурацию и битовые регистры FIFO. +
Запрещена запись в другие поля регистра, когда бит EN читается как 1. +
Примечание.  +
Прежде чем установить бит EN в «1» для начала новой передачи, флаги событий,
соответствующие потокам в регистрах *DMA_LISR или DMA_HISR должны быть очищены*.

.Регистр DMA_LISR
image::DMA_LISR.png[]


.Регистр DMA_HISR
image::DMA_HISR.png[]

Теперь сконфигурируем АЦП и DMA.

.Регистр управления АЦП 1 (ADC_CR1)
image::ADC_CR1.png[]

Биты 25:24 RES[1:0]: Разрядность АЦП

- *00: 12-bit*
- 01: 10-bit
- 10: 8-bit
- 11: 6-bit

.Регистр регулярной последовательности АЦП 1 (ADC_SQR1)
image::ADC_SQR1.png[]

Биты 23:20 L[3:0]: Обычная длина последовательности каналов
Эти биты записываются программным обеспечением для определения общего количества
преобразований в обычном режиме.

- *0000: 1 измерение*
- 0001: 2 измерения
- ...
- 1111: 16 измерений

.Регистр регулярной последовательности АЦП 3 (ADC_SQR3)
image::ADC_SQR3.png[]

Биты 4:0 SQ1[4:0]: 1-е преобразование в обычной последовательности.

.Регистр шага выборки АЦП 1 (ADC_SMPR1)
image::ADC_SMPR1.png[]

Биты 26:0 SMPx[2:0]: Выбор времени выборки канала x
Эти биты записываются программным обеспечением для индивидуального выбора
времени дискретизации для каждого канала.
Во время цикла выборки, биты выбора канала должны оставаться неизменными.

- *000: 3 цикла*
- 001: 15 циклов
- 010: 28 цикла
- 011: 56 цикла
- 100: 84 цикла
- 101: 112 цикла
- 110: 144 цикла
- 111: 480 цикла

.Поток DMAx регистра адреса периферии (DMA_SxPAR) (x = 0..7)
image::DMA_SxPAR.png[]

.Поток DMAx регистра адреса памяти 0 (DMA_SxM0AR) (x = 0..7)
image::DMA_SxM0AR.png[]

.Поток DMAx регистра адреса памяти 1 (DMA_SxM1AR) (x = 0..7)
image::DMA_SxM1AR.png[]

.Поток DMAx номера регистра данных (DMA_SxNDTR) (x = 0..7)
image::DMA_SxNDTR.png[]

Биты 15:0 NDT[15:0]: Количество элементов данных для передачи
Количество элементов данных для передачи (от 0 до 65535). Этот регистр может
быть записан только когда поток отключен.
Когда поток включен, этот регистр доступен только для чтения, указывая
оставшиеся элементы данных, подлежащие передаче.
Этот регистр уменьшается после каждого прямого доступа к памяти.
После завершения передачи этот регистр может либо оставаться на нуле
(когда поток находится в нормальном режиме) либо автоматически перезагружаться
ранее запрограммированным значением в следующие случаи:
– когда поток настроен в циклическом режиме.
– когда поток снова включен, установив бит EN в «1».
Если значение этого регистра равно нулю, транзакция не может быть обслужена,
даже если поток включён.

.Поток DMAx регистра управления FIFO (DMA_SxFCR) (x = 0..7)
image::DMA_SxFCR.png[]

.Регистр состояния АЦП (ADC_SR)
image::ADC_SR.png[]

Бит 1 EOC: Окончание конверсии обычного канала

- 0: Преобразование не завершено (EOCS=0) или
последовательность преобразований не завершена (EOCS=1).
- *1: Преобразование завершено (EOCS=0) или
завершена последовательность преобразований (EOCS=1).*

.Регистр обычных данных АЦП (ADC_DR)
image::ADC_DR.png[]

==== Порядок запуска ADC с подключённым к нему DMA:

1. Подключить DMA к источнику тактирования – устанавливаем бит DMA2EN в
регистре RCC::AHB2ENR (DMA тактируется от шины AHB1).

2. Подключить АЦП к источнику тактирования – устанавливаем бит ADC1EN в
регистре RCC::APB2ENR (АЦП тактируется от шины APB2).

3. Сконфигурировать порты АЦП и DMA.
Определиться по каким каналам будут проводиться измерения,
затем соответствующие выводы портов настроить для работы в аналоговом режиме.

4. Отключить поток, сбросив бит EN в регистре DMA_SxCR, затем прочитайте
этот бит, чтобы убедиться в отсутствии текущей потоковой операции.
Когда бит EN читается как 0, это означает, что поток готов к настройке.

5. Сконфигурировать АЦП и DMA.

- Установить разрядность в регистре ADC::CR1
- Установить режим непрерывного преобразование в регистре ADC::CR1
(биты CONT и EOCS установить в нужное значение)
- установить количество измерений в регистре ADC1::SQR1 бит L
- Выбрать канал для первого преобразования в регистре ADC1::SQR3 биты SQ1
- Установить скорость дискретизации в регистре SMPRx для нужного канала

6. Установить адрес регистра периферийного порта в регистре DMA_SxPAR.
Данные будут перемещаться на этот адрес с периферийного порта после
периферийного события.

7. Установить адрес памяти в регистре DMA_SxM0AR (и в регистре DMA_SxM1AR).
Данные будут записываться или считываться из этой памяти после периферийного
события.

8. Настроить общее количество элементов данных,
которые будут переданы в DMA_SxNDTR регистр.

9. Выбрать канал DMA (запрос), используя CHSEL[2:0] в регистре DMA_SxCR.

10. Если периферийное устройство предназначено для управления потоком и
поддерживает эту функцию, установите бит PFCTRL в регистре DMA_SxCR.

11. Настроить приоритет потока, используя биты PL[1:0] в регистре DMA_SxCR.

12. Настроить использование FIFO
(включение или отключение, пороговое значение при передаче и приеме).

13. Настроить регистр DMA_SxCR.

14. Активируйте поток, установив бит EN в регистре DMA_SxCR. +
Как только поток включен, он может обслуживать любой запрос DMA от
периферийного устройства подключённого к потоку. +
Чтобы выключить периферийное устройство, подключенное к потоку DMA
запроса, необходимо сначала отключить поток DMA для
к которому подключено периферийное устройство, то ждать бит EN = 0.
Только после этого периферийное устройство можно безопасно отключить. +
Когда режим DMA включен (бит DMA установлен в 1 в регистре ADC_CR2),
после каждого преобразование обычного канала, генерируется запрос DMA.
Это позволяет передавать преобразованные данные из регистра ADC_DR в место
назначения.

15. Включить АЦП. Это делается установкой бита ADON в регистре ADC::CR2.

16. Запустить АЦП на преобразование установкой бита SWSTART в регистре
ADC::CR2 для регулярных каналов

17. Дождаться готовности бита EOC в регистре ADC::SR

18. Считать данные из регистра ADC::DR

=== Расчёт температуры
Температура, согласно заданию, считает по следующей формуле: +
T = At + code * Bt + code^2 * Ct , +
где At,Bt,Ct - градуировочные коэффициенты; +
code – код АЦП; +
T - температура
Для терморезистора pt100 представлена следующая зависимсоть взятая с даташита на
терморезистор c сайта:
https://www.2150692.ru/tovary/sensors/thermal/product/view/25/432

.Функция зависимости сопротивления от температуры
image::Терморезистор_Функция.png[]

Определим нелинейность данной функции и подберём градуировочные коэффициенты
в программе: https://www.wolframalpha.com/.

.Расчёт коэффициентов для терморезистора
image::Расчёт коэффициентов для терморезистора.png[]

Итого получили градуировочные коэффициенты: +
At = -246,746; +
Bt =  2,37684; +
Ct = 0,000907965; +
Данные величины буду храниться в памяти микроконтроллера типом float
(знаковое 32 байтовое вещественное число), т.к. данная разрядная сетка в 4 байта
(32 бита) позволяет хранить такие числа без существенного искажения.

.Пример искажения числа при хранении его типом float
image::Пример искажения числа при хранении его типом float.png[]

Т.к. наше АЦП явлется 12-разрядным, то 2^12 = 4096, т.е. измеряемый диапазон
температуры (code) составляет от 0 до 4095 отсчётов АЦП.
Температура на ФЭУ изменяется от -50 до +30 градусов Цельсия.
По техническим причинам не получается охлаждать ФЭУ ниже -50 градусов Цельсия,
а в помещении, отведённом под эксплуатацию метрологического комплекса даже в
самый жаркий летний день температура не подымается выше +30 градусов Цельсия.
Посчитав (30-(-50)) / 4096 = 0,02 получим, что 0,02 градуса приходится на один
отсчёт АЦП, т.е. погрешность АЦП на данном температурном участке составляет
0,02 градуса Цельсия. +
С учётом градуировочных коэффициентов при расчёте температуры, получим
следующую нелинейность терморезистора.

.Квадратичная зависимость термосопротивления
image::Квадратичная зависимсоть термосопротивления.png[]

Погрешность АЦП = 0,020 градуса Цельсия. +
Погрешность формулы = 0,066 градуса Цельсия. +
Итого: 0,020 + 0,066 = 0,086 градусов Цельсия составляет погрешность измерения,
это позволяет измерять температуру с точностью до ±0,1 градус Цельсия.
Согласно ТЗ нас это устраивает.

=== ОСРВ
Согласно заданию необходимо проводить измерения ежесекундно.
Для этих целей хорошо использовать операционную систему реального времени (ОСРВ).
ОСРВ поможет создать несколько разнородных задач, выполнение которых будет
происходить в заданные периоды времени. +
Итак, составим задачи для ОСРВ:

 1. Ежесекундное измерение температуры при помощи АЦП и складывание полученных
данных при помощи DMA в регистры памяти микроконтроллера.
Данная задача осуществляет считывание с терморезистора значение в виде кода АЦП,
считает по формуле (переводит в температуру) и посчитанное значение температуры
заносит в память микроконтроллера, где эти данные становятся всем доступные.
 2. Задача, проверяющая нужно ли отключить элементы Пельтье.
Данная задача будет брать данные (температуру и расход воды в кране из памяти
микроконтроллера) и принимать решение подавать ли питание на пин, ведущий к
элементам Пельтье.
 3. Задача регулирования силы тока при помощи широтно-импульсной модуляции (ШИМ).
Данная задача будет брать данные (текущая температура на ФЭУ, рассчитанная АЦП и
заданна температура, которая передаётся по Modbus с приложения верхнего уровня).
Данная задача осуществляет расчёт CCR
 4. Ежесекундное измерение расхода воды в кране.

=== Регулирование силы тока ШИМом

Согласно задаю, необходимо регулировать силу тока, протекающую по элементам
Пельтье. Для плавного регулирования силы тока хорошо использовать
широтно-импульсную модуляцию (ШИМ). Для регулирования силы тока при помощи ШИМ
используются такие параметры ШИМа как ARR - максимальное число импульсов и
CCR - отвечающий за коэффициент заполнения. +
В STM32F411RE есть один ШИМ-таймер - таймер расширенного управления (TIM1).
Данный таймер также поддерживает DMA.





