---
title: Курсовой
---
:reproducible:

:description: Kursovow
:keywords: AsciiDoc
:imagesdir: ImgKursovow
:figure-caption: Рисунок
:table-caption: Таблица


:toc-title: Содержание
:toc:

[#_курсовой]
= Курсовой

[text-right]
--

--

== Глава 1. Анализ требований
Необходимо разработать устройство для охлаждения метрологического стенда.
Для этого сперва определим какие необходимы функции и переферия
для разрабатываемого устройства. +

=== АЦП с возможностью прямого доступа к памяти
Согласно заданию необходимо измерять температуру при помощи АЦП, при этом,
полученные данные с АЦП должны передаваться сразу в память устройства,
это обеспечивается при помощи DMA (контроллера прямого доступа к памяти).
В микроконтроллер STM32F411RE встроено 2 DMA каждый из которых является
8 поточным FIFO (по типу очереди, первый байт данных пришёл и первый же ушёл).
DMA поддерживает циклическое управление буфером,
т.е. пока половина буфера наполняется со второй (уже полностью заполненной)
можно производить какие-либо действия.

Каждый поток связан с запросом DMA, который можно выбрать из 8 возможных
запросов канала. Выбор управляется битами CHSEL[2:0] в DMA_SxCR регистр. +
Только DMA2 имеет возможность записывать с ADC1 данные в память и только
по каналу 0. Поэтому дальше будет опираться на ADC1 и DMA2.

.Канал 0
image::DMA_DMA2 и ADC1.png[]

.Расположение в памяти встроенных DMA
image::Область памяти DMA.png[]

.Подача тактирования на DMA по шине AHB1
image::Тактирование DMA2.png[]

Бит 22 DMA2EN: подача системного тактирования на DMA2

- 0: DMA2 выключить
- *1: DMA2 включить*

Помимо DMA также тактирование необходимо подать и АЦП.

.Подача тактирования на ADC по шине APB2
image::Тактирование на ADC.png[]

Бит 8 ADC1EN: Тактирование ADC1

- 0: ADC1 выключить
- *1: ADC1 включить*

Необходимо настроить порты DMA и ADC.

.Регистр конфигурации потока DMA DMA_SxCR
image::DMA_SxCR.png[]

Биты 27:25 CHSEL[2:0]: Выбор канала.

- *000: канал 0*
- 001: канал 1
- 010: канал 2
- 011: канал 3
- 100: канал 4
- 101: канал 5
- 110: канал 6
- 111: канал 7

Эти биты защищены и могут быть записаны, только если EN равен «0».

Бит 19 CT: отвечает за выбор целевого буфера в режиме двойной буферизации

- *0: Текущая целевая память — 0 (адресуется указателем DMA_SxM0AR)*
- 1: Текущая целевая память — 1 (адресуется указателем DMA_SxM1AR)

Бит 18 DBM: Двойной буферный режим

- 0: Нет переключения буфера в конце передачи
- *1: Целевой объект памяти переключается в конце передачи DMA* +
Этот бит защищен и может быть записан, только если EN равен «0».

Биты 14:13 MSIZE[1:0]: Размер данных памяти +
Отвечает за то, куда будут сыпаться данные.
Т.к. процессор у нас 32-разрядный, то можно выделить 32 бита.

- 00: byte (8-bit)
- 01: half-word (16-bit)
- *10: word (32-bit)*
- 11: reserved

Эти биты защищены и могут быть записаны, только если EN равен «0».
В прямом режиме MSIZE принудительно устанавливается аппаратно на то же значение,
что и PSIZE, как только бит EN = «1».

Биты 12:11 PSIZE[1:0]: Размер периферийных данных +
Т.к. регистр АЦП 32-разрядный, то имеет смысл в регистр DMA
(который тоже 32-разрядный) записывать 32-разрядное значение.

- 00: Byte (8-bit)
- 01: Half-word (16-bit)
- *10: Word (32-bit)*
- 11: reserved

Эти биты защищены и могут быть записаны, только если EN равен «0».

Бит 8 CIRC: Циклический режим
Этот бит устанавливается и сбрасывается программно и может быть сброшен аппаратно.

- 0: disabled
- *1: enabled*

Когда периферийное устройство является контроллером потока (бит PFCTRL = 1) и
поток включен (бит EN = 1), то этот бит аппаратно автоматически устанавливается
в 0. Он автоматически устанавливается аппаратно в 1, если бит DBM установлен,
как только поток включено (бит EN = 1).

Биты 7:6 DIR[1:0]: Направление передачи данных
Эти биты устанавливаются и очищаются программным обеспечением.

- *00: Из периферийного устройства в память*
- 01: Из памяти в периферию
- 10: Из памяти в память
- 11: Зарезервировано

Эти биты защищены и могут быть записаны, только если EN равен «0».

Бит 5 PFCTRL: Контроллер периферийного потока
Этот бит устанавливается и сбрасывается программно.

- 0: *DMA — это контроллер потока*
- 1: Периферийное устройство — это контроллер потока

Этот бит защищен и может быть записан, только если EN равен «0».
Когда выбран режим памяти в память (биты DIR[1:0]=10), этот бит
автоматически сбрасывается на 0 аппаратно.

Бит 0 EN: Включить поток / пометить поток как готовый при низком уровне чтения
Этот бит устанавливается и сбрасывается программно.

- 0:  disabled
- *1:  enabled*

Когда этот бит считывается как 0, программе разрешено программировать
конфигурацию и битовые регистры FIFO. +
Запрещена запись в другие поля регистра, когда бит EN читается как 1. +
Примечание.  +
Прежде чем установить бит EN в «1» для начала новой передачи, флаги событий,
соответствующие потокам в регистрах *DMA_LISR или DMA_HISR должны быть очищены*.

.Поток DMAx регистра адреса памяти 0 (DMA_SxM0AR) (x = 0..7)
image::DMA_SxM0AR.png[]
Адрес переменной со значениями хранится по адресу DMA_S0M0AR

.Регистр DMA_LISR
image::DMA_LISR.png[]


.Регистр DMA_HISR
image::DMA_HISR.png[]

Теперь сконфигурируем АЦП и DMA.

.Регистр управления АЦП 1 (ADC_CR1)
image::ADC_CR1.png[]

Биты 25:24 RES[1:0]: Разрядность АЦП

- *00: 12-bit*
- 01: 10-bit
- 10: 8-bit
- 11: 6-bit

Теперь необходимо настроить АЦП, чтобы оно работало в режиме DMA.
Для измерения используются инжекторные каналы.
Они позволяют одновременно измерять и складывать в 4 ячейки свои значения.

Бит 12 JDISCEN: включает/отключает прерывистый режим инжектированных каналов
Этот бит устанавливается и очищается программно, чтобы включить/Выключит

- 0: прерывистое режим инжектированных каналов отключены
- *1: прерывистое режим инжектированных каналов включены*

Бит 10 JAUTO: автоматическое преобразование инжектированной группы каналов
Этот бит устанавливается и очищается программно для разрешения/запрета
автоматического преобразования группы после преобразования регулярной группы.

- *0: автоматическое преобразование инжектированной группы выкл.*
- 1: автоматическое преобразование инжектированной группы вкл.

Бит 8 SCAN: режим сканирования
Этот бит устанавливается и сбрасывается программным обеспечением
для включения/отключения режима сканирования.
В режиме сканирования входы, выбранные через регистры ADC_SQRx или ADC_JSQRx,
преобразуются.

- 0: режим сканирования отключен
- *1: режим сканирования включен*

Примечание. Прерывание EOC генерируется, если установлен бит EOCIE: +
– В конце каждой регулярной групповой последовательности, если бит EOCS сброшен в 0 +
– В конце каждого обычного преобразования канала, если бит EOCS установлен в 1  +
Примечание. Прерывание JEOC генерируется только в конце преобразования последнего
канала, если Бит JEOCIE установлен.

.Регистр управления ADC_CR2
image::ADC_CR2.png[]

Бит 30 SWSTART: Начать преобразование обычных каналов

-*0: Сбросить состояние*
- 1: Запускает преобразование обычных каналов*
Примечание.  +
Этот бит можно установить, только если ADON = 1, в противном случае
преобразование не запускается.

Бит 22 JSWSTART: начать преобразования инжектированных каналов +
Этот бит устанавливается программно и очищается аппаратно,
как только начнется преобразование.

- 0: сброс состояния
- *1: запуск преобразования инжектированных каналов*

Примечание: этот бит может быть установлен только тогда, когда ADON = 1,
В противном случае преобразование не запускается.

Бит 10 EOCS: Конец выбора преобразования

- 0: Бит EOC устанавливается в конце каждой последовательности обычных
преобразований. Обнаружение переполнения включается, только если DMA=1.
- *1: Бит EOC устанавливается в конце каждого обычного преобразования.
Обнаружение переполнения включено.*

Бит 9 DDS: Выбор отключения DMA (для режима одиночного АЦП)

- 0: После последней передачи не выдается новый запрос DMA
(как настроено в контроллере DMA)
- *1: Запросы DMA выдаются до тех пор, пока данные конвертируются и DMA=1.*

Запросы могут продолжать генерироваться, если бит DDS установлен в 1.
Это позволяет настроить DMA в циклическом режиме с двойным буфером.

Бит 8 DMA: Режим прямого доступа к памяти (для режима одиночного АЦП)

- 0: режим DMA выключен
- 1: *режим DMA включен*

Бит 1 CONT: Непрерывное преобразование
Этот бит устанавливается и сбрасывается программно.
Если он установлен, преобразование происходит непрерывно, пока не будет очищен.

- 0: Одиночный режим преобразования
- *1: Непрерывный режим преобразования*

Бит 0 ADON: Аналого-цифровой преобразователь ВКЛ./ВЫКЛ.

- 0: Отключение преобразования АЦП и переход в режим отключения питания.
- *1: Включить АЦП*

Теперь необходимо настроить DMA.
Выше было показано, что ADC1 может использоваться на 0 канале. Но т.к. данный
регистр настраивается только при сброшенном EN, то сперва необходимо установить
EN = 0, а затем уже настраивать каналы.

.Регистр шага выборки АЦП 1 (ADC_SMPR1)
image::ADC_SMPR1.png[]

Биты 26:0 SMPx[2:0]: Выбор времени выборки канала x +
Эти биты записываются программным обеспечением для индивидуального выбора
времени дискретизации для каждого канала.
Во время цикла выборки, биты выбора канала должны оставаться неизменными.

- 000: 3 цикла
- 001: 15 циклов
- 010: 28 цикла
- 011: 56 цикла
- *100: 84 цикла*
- 101: 112 цикла
- 110: 144 цикла
- 111: 480 цикла

.Регистр инжекторной последовательности АЦП 1 (ADC_JSQR)
image::ADC_jSQR.png[]

Биты 21:20 JL[1:0]: длина введенной последовательности

- *00: 1 преобразование*
- 01: 2 преобразования
- 10: 3 преобразования
- 11: 4 преобразования

Биты 19:15 JSQ4 [4:0]: канал для 4-го преобразования.

Биты 14:10 JSQ3 [4:0]: канал для 3-го преобразования.

Биты 9:5 JSQ2 [4:0]: канал для 2-го преобразования.

Биты 4:0 JSQ1 [4:0]: канал для 1-го преобразования.

В случае, если требуется опрашивать число каналов меньше 4, то биты JSQ смещаются в сторону старших разрядов.

image::ADC_jSQR_Primechanie.png[]

.Поток DMAx регистра адреса периферии (DMA_SxPAR) (x = 0..7)
image::DMA_SxPAR.png[]

В регистр DMA_S0PAR пропишем регистр инжекторного канала ADC_JDR4,
чтобы данные из АЦП канала сразу же уходили в регистр DMA.

.Инжекторные данные АЦП (x = 1..4)
image::ADC_JDRx.png[]

.Поток DMAx номера регистра данных (DMA_SxNDTR) (x = 0..7)
image::DMA_SxNDTR.png[]

Биты 15:0 NDT[15:0]: Количество элементов данных для передачи
Количество элементов данных для передачи (от 0 до 65535). Этот регистр может
быть записан только когда поток отключен.
Когда поток включен, этот регистр доступен только для чтения, указывая
оставшиеся элементы данных, подлежащие передаче.
Этот регистр уменьшается после каждого прямого доступа к памяти.
После завершения передачи этот регистр может либо оставаться на нуле
(когда поток находится в нормальном режиме), либо автоматически перезагружаться
ранее запрограммированным значением в следующие случаи:
– когда поток настроен в циклическом режиме.
– когда поток снова включен, установив бит EN в «1».
Если значение этого регистра равно нулю, транзакция не может быть обслужена,
даже если поток включён.

В регистр DMA_S0NDTR запишем 1,
потому что за один раз DMA перекинет 32-битное число с АЦП.

.Регистр состояния АЦП (ADC_SR)
image::ADC_SR.png[]

Бит 1 EOC: Окончание конверсии обычного канала

- 0: Преобразование не завершено (EOCS=0) или
последовательность преобразований не завершена (EOCS=1).
- *1: Преобразование завершено (EOCS=0) или
завершена последовательность преобразований (EOCS=1).*

.Регистр обычных данных АЦП (ADC_DR)
image::ADC_DR.png[]

==== Порядок запуска ADC с подключённым к нему DMA:

. Подключить DMA к источнику тактирования – устанавливаем бит DMA2EN в
регистре RCC::AHB2ENR (DMA тактируется от шины AHB1).

. Подключить АЦП к источнику тактирования – устанавливаем бит ADC1EN в
регистре RCC::APB2ENR (АЦП тактируется от шины APB2).

. Сконфигурировать порты АЦП и DMA.
Определиться по каким каналам будут проводиться измерения,
затем соответствующие выводы портов настроить для работы в аналоговом режиме. +
TBD: т.к. потенциометр находится на плате расширения и привязан к РА0,
то необходимо подать тактирование на порт А: +
RCC::AHB1ENR::GPIOAEN::Enable::Set(), +
А затем назначить данный пин как аналоговый: +
GPIOA::MODER::MODER0::Analog::Set().


. Отключить поток, сбросив бит EN в регистре DMA_SxCR, затем прочитать
этот бит, чтобы убедиться в отсутствии текущей потоковой операции.
Когда бит EN читается как 0, это означает, что поток готов к настройке.

. Сконфигурировать АЦП и DMA.

- Установить разрядность в регистре ADC::CR1
- Установить режим непрерывного преобразование в регистре ADC::CR1
(биты CONT и EOCS установить в нужное значение)
- установить количество измерений в регистре ADC1::SQR1 бит L
- Выбрать канал для первого преобразования в регистре ADC1::SQR3 биты SQ1
- Установить скорость дискретизации в регистре SMPRx для нужного канала

. Установить адрес регистра периферийного порта в регистре DMA_SxPAR.
Данные будут перемещаться на этот адрес с периферийного порта после
периферийного события.
В регистр DMA_S0PAR пропишем регистр инжекторного канала ADC_JDR4.

. Установить адрес памяти в регистре DMA_SxM0AR (и в регистре DMA_SxM1AR).
Данные будут записываться или считываться из этой памяти после периферийного
события.

. Настроить общее количество элементов данных,
которые будут переданы в DMA_SxNDTR регистр.

. Выбрать канал DMA (запрос), используя CHSEL[2:0] в регистре DMA_SxCR.

. Настроить использование FIFO
(включение или отключение, пороговое значение при передаче и приеме).

. Активируйте поток, установив бит EN в регистре DMA_SxCR. +
Как только поток включен, он может обслуживать любой запрос DMA от
периферийного устройства подключённого к потоку. +
Чтобы выключить периферийное устройство, подключенное к потоку DMA
запроса, необходимо сначала отключить поток DMA для
к которому подключено периферийное устройство, то ждать бит EN = 0.
Только после этого периферийное устройство можно безопасно отключить. +
Когда режим DMA включен (бит DMA установлен в 1 в регистре ADC_CR2),
после каждого преобразование обычного канала, генерируется запрос DMA.
Это позволяет передавать преобразованные данные из регистра ADC_DR в место
назначения.

. Включить АЦП. Это делается установкой бита ADON в регистре ADC::CR2.

. Запустить АЦП на преобразование установкой бита SWSTART в регистре
ADC::CR2 для регулярных каналов

=== Расчёт температуры
Температура, согласно заданию, считает по следующей формуле:
[stem]
++++
T = At + code * Bt + code^2 * Ct ,
++++

где At,Bt,Ct - градуировочные коэффициенты; +
code – код АЦП; +
T - температура

Температура на ФЭУ изменяется от -50 до +30 градусов Цельсия.
По техническим причинам не получается охлаждать ФЭУ ниже -50 градусов Цельсия,
а в помещении, отведённом под эксплуатацию метрологического комплекса даже в
самый жаркий летний день температура не подымается выше +30 градусов Цельсия. +

Для терморезистора pt100 представлена следующая зависимость взятая с даташита на
терморезистор c сайта:
https://www.2150692.ru/tovary/sensors/thermal/product/view/25/432

.Функция зависимости сопротивления от температуры
image::Терморезистор_Функция.png[]

Определим нелинейность данной функции и подберём градуировочные коэффициенты
в программе: https://www.wolframalpha.com/.

.Расчёт коэффициентов для терморезистора
image::Расчёт коэффициентов для терморезистора.png[]

Итого получили градуировочные коэффициенты: +
At = -246,584; +
Bt =  2,37383; +
Ct = 0,000921853; +
Данные величины буду храниться в памяти микроконтроллера типом float
(знаковое 32 байтовое вещественное число), т.к. данная разрядная сетка в 4 байта
(32 бита) позволяет хранить такие числа без существенного искажения.

.Пример искажения числа при хранении его типом float
image::Пример искажения числа при хранении его типом float.png[]

Т.к. наше АЦП явлется 12-разрядным, то 2^12 = 4096, т.е. измеряемый диапазон
температуры (code) составляет от 0 до 4095 отсчётов АЦП.
Температура на ФЭУ изменяется от -50 до +30 градусов Цельсия. +
Посчитав (30-(-50)) / 4096 = 0,02 получим, что 0,02 градуса приходится на один
отсчёт АЦП, т.е. погрешность АЦП на данном температурном участке составляет
0,02 градуса Цельсия. +
С учётом градуировочных коэффициентов при расчёте температуры, получим
следующую нелинейность терморезистора.

.Квадратичная зависимость термосопротивления
image::Квадратичная зависимсоть термосопротивления.png[]

Существуют специальные методы обработки сигналов, позволяющие увеличить разрешение
измерений. С помощью метода называемого *оверсемплинг* и *децимация*.
Данные методы используют большее число выборок сигнала, тем самым увеличив частоту
его дискретизации.
Для каждого дополнительного бита разрешения требуется увеличение частоты
дискретизации в 4 раза.
Большее количество выборок нужно для лучшего представления входного аналогового
сигнала при усреднении.
Обычный смысл усреднения заключается в сложении *m* выборок сигнала и
делении полученного результата на *m*. Это так называемое нормальное усреднение.
Очень часто для этого также используется метод скользящего среднего.
Он заключается в усреднении выборок сигнала внутри циклической очереди.
В этом случае каждая усредненная выборка сигнала будет представлена несколькими
самыми последними выборками. Что будет давать небольшую временную задержку.
Методы *оверсемплинга* и *децимации*  работают только при наличии Гауссовского шума,
который отличается широкой полосой частот и равномерным распределением энергии по
всей полосе. Метод *оверсемплинга* и *децимации* будет работать, если амплитуда
шума достаточна для переключения преобразования АЦП.

Погрешность АЦП = 0,02 градуса Цельсия. +
Погрешность формулы = 0,03 градуса Цельсия. +
Итого: 0,02 + 0,03 = 0,05 градусов Цельсия составляет погрешность измерения,
это позволяет измерять температуру с точностью до ±0,1 градус Цельсия.
Согласно ТЗ нас это устраивает.

=== ОСРВ
Согласно заданию необходимо проводить измерения ежесекундно.
Для этих целей хорошо использовать операционную систему реального времени (ОСРВ).
ОСРВ поможет создать несколько разнородных задач, выполнение которых будет
происходить в заданные периоды времени. +
Итак, составим задачи для ОСРВ:

. Измерение температуры при помощи АЦП и складывание полученных
данных при помощи DMA в регистры памяти микроконтроллера. +
Данная задача осуществляет считывание с терморезистора значение в виде кода АЦП,
считает по формуле (переводит в температуру) и посчитанное значение температуры
заносит в память микроконтроллера, где эти данные становятся всем доступные.
. Ежесекундное измерение расхода воды в кране. +
Данная задача запускает таймер в режиме захвата,
который измеряет количество импульсов, пришедших за 10 миллисекунд.
Затем переводит по формуле в скорость и по DMA данные записываются в память
микроконтроллера.
. Задача регулирования силы тока при помощи широтно-импульсной модуляции (ШИМ). +
Ежесекундно данная задача берёт данные (текущая температура на ФЭУ, рассчитанная АЦП,
заданна температура, которая передаётся по Modbus с приложения верхнего уровня и
скорость потока воды с расходомера). Данная задача осуществляет расчёт CCR, т.е.
изменяя коэффициент заполнения сигнала, на пин будет подаваться напряжение от 0 В до
опорного 3,3 В. Т.о. плавное изменение CCR может в случае отсутсвия воды и
повышения температуры на элементах Пельтье отключить элементы Пельтье, выставив CCR=0.
. Передача данных по Modbus. +
Принимает и передаёт данные по Modbus.

=== Регулирование силы тока ШИМом

Согласно заданию, необходимо регулировать силу тока, протекающую по элементам
Пельтье. Для плавного регулирования силы тока хорошо использовать
широтно-импульсную модуляцию (ШИМ). Для регулирования силы тока при помощи ШИМ
используются такие параметры ШИМа как ARR - максимальное число импульсов и
CCR - отвечающий за коэффициент заполнения. +
В STM32F411RE буду использовать один ШИМ-таймер - таймер расширенного управления (TIM1).
Данный таймер также поддерживает DMA, что позволит записывать рассчитанное значение
протекающего тока по элементам Пельтье.

Буду использовать четвёртый канал таймера TIM1.
Поэтому после подачи тактирования на пины GPIOA (RCC::AHB1ENR::GPIOAEN::Enable::Set())
назначу пин PA11 альтернативным (GPIOA::MODER::MODER11::Alternate::Set()).

.Вывод PA11
image::OutputPA11.png[]

.Включение таймера TIM1
image::TIM1_RCC_APB2ENR.png[]
Бит 0 TIM1EN: часы TIM1 включены

- 0: часы TIM1 отключены +
- *1: часы TIM1 включены* +

.Сброс таймера TIM1
image::TIM1_RCC_APB2RSTR.png[]
Бит 0 TIM1RST: сброс TIM1

- 0: не сбрасывает TIM1
- *1: сбрасывает TIM1*

Режим широтно-импульсной модуляции (ШИМ) позволяет генерировать сигнал с частотой,
определяемой значение регистра TIM1_ARR и рабочий цикл,
определяемый значением регистра TIM1_CCR4.

TIM1_ARR – регистр автоматической перезагрузки,
счётчик считает от 0 до TIM1_ARR, или наоборот в зависимости от направления счёта,
изменяя это значение, можно изменять частоту ШИМ-сигнала.

TIM1_CCR4[TIM1 – номер таймера, CCR4 – номер канала] –
определяет коэффициент заполнения ШИМ.

.Регистр управления TIM1
image::TIM1_CR1.png[]
Бит 4 DIR: Направление

- *0: Счетчик используется в качестве счетчика*
- 1: Счетчик используется как обратный счетчик +
Примечание. Этот бит считывается только в том случае,
если таймер настроен в режиме с выравниванием по центру или в режиме энкодера.

Бит 0 CEN: Разрешение счетчика

- 0: Счетчик отключен
- *1: Счетчик включен*

.Регистр TIM1_BDTR
image::TIM1_BDTR.png[]
Бит 15 MOE: Активация главного выхода

- 0: использование вывода таймера как вход
- *1: использование вывода таймера как выход*

.Регистр TIM1_CCER
image::TIM1_CCER.png[]

Бит 12 CC4E: выход захвата/сравнения 1 включен.
*Канал CC4 настроен как выход:*

- 0: Выкл. — OC4 не активен
- *1: Вкл. - сигнал OC4 выводится на соответствующий выходной контакт*

Канал CC4 настроен как вход:
Этот бит определяет, действительно ли можно выполнить захват значения счетчика на входе.
регистр захвата/сравнения 1 (TIMx_CCR4) или нет.

- 0: Захват отключен
- 1: Захват включен

Добавим в DMA таймер TIM1, чтобы значения с ШИМ-сигнала имели доступ к памяти.
У нас уже занят 1 канал АЦП, поэтому воспользуемся другим свободным,
например 6 каналом и потоком 1.

.Канал 6
image::DMA_DMA2 и TIM1.png[]
Теперь настроим канал DMA.
Выше было показано, что TIM1 может использоваться на 6 канале.
Но т.к. нельзя одновременно использовать 2 канала,
необходимо будет переключаться между двумя каналами.

.Регистр конфигурации потока DMA DMA_SxCR
image::DMA_SxCR.png[]

Биты 27:25 CHSEL[2:0]: Выбор канала.

- *000: канал 0*
- 001: канал 1
- 010: канал 2
- 011: канал 3
- 100: канал 4
- 101: канал 5
- *110: канал 6*
- 111: канал 7

Сила тока рассчитывается по формуле:
[stem]
++++
I = Ai * duty ,
++++
где Ai - коэффициент зависимости; +
duty - коэффициент заполнения в %,

Зависимость скважности от температуры описывается следующей формулой:
[stem]
++++
Duty(t) = K_(p) * e(t) + K_i int_0^tau e(t)dt + K_d * (de(t))/dt,
++++
где Duty - скважность % (от 0 до 100%); +
dt = 1000ms+ e(t) - ошибка между 23С и текущей измеренной температурой; +
Kp - пропорциональный коэффициент; +
Ki - интегральный коэффициент; +
Kd - дифференциальный коэффициент. +

=== Измерение расхода воды
Для измерения расхода воды используется датчик SEN02141B. Однако, для имитации
работы расходомера используется плата STM32F103C8T6.
Имитация производится при помощи частотно-импульсной модуляции (ЧИМ).
Для платы STM32F411RE потребуется таймер в режиме захвата,
а для платы STM32F103C8T6


=== Передача данных по ModBus
ModBus регистры являются 16-битными.
Адреса регистров:

- Температура: (Input Registers) : 30001 (Float32)
- Расход: (Input Registers) : 30003 (Float32)
- code: (Input Registers) : 30005 (Float32)
- duty: (Input Registers) : 30007 (Float32)
- Аt: (Holding Registers) : 40001 (Float32)
- Bt: (Holding Registers) : 40003 (Float32)
- Ct: (Holding Registers) : 40005 (Float32)
- Ai: (Holding Registers) : 40007 (Float32)
- Kp: (Holding Registers) : 40009 (Float32)
- Ki: (Holding Registers) : 40011 (Float32)
- Kd: (Holding Registers) : 40013 (Float32)

== Глава 2. Дизайн программы
Проанализировав требования, составим дизайн программы, обозначим классы и их методы.


[plantuml]

----

class IMeasureParameter
{
  Calculate(in int32_t code): float
}

class Temperature
{
  IsMeasureTemperature(in int32_t code): float
}
class WaterConsumtion
{
IsMeasureConsumtion(in int32_t code): float
}
class Current
{
IsMeasureCurrent(in int32_t code): float
}

IMeasureParameter<|--Temperature
IMeasureParameter<|--WaterConsumtion
IMeasureParameter<|--Current

class ADC
{
StartConversation():void
GetResult():int32_t
IsConversionComplete():bool
TransmitData():void
}

class PWM
{
RecalculateCCR():void
Send():void
}

class Flowmeter
{
GetResult():int32_t
IsCapturePulsComplete():bool
}
class Modbus
{
GetData():void
Send():void
IsSendDataComplete():bool
}

Temperature o--ADC
Current o--PWM
WaterConsumtion o--Flowmeter

ADC o--Modbus
PWM o--Modbus
Flowmeter o--Modbus
----





