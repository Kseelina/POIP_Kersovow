---
title: Курсовой
---
:reproducible:

:description: Kursovow
:keywords: AsciiDoc
:imagesdir: ImgKursovow
:figure-caption: Рисунок
:table-caption: Таблица


:toc-title: Содержание
:toc:

[#_курсовой]
= Курсовой

[text-right]
--

--

== Глава 1. Анализ требований
Необходимо разработать устройство для охлаждения метрологического стенда.
Для этого сперва определим какие необходимы функции и переферия
для разрабатываемого устройства. +

=== АЦП с возможностью прямого доступа к памяти
Согласно заданию необходимо измерять температуру при помощи АЦП, при этом,
полученные данные с АЦП должны передаваться сразу в память устройства,
это обеспечивается при помощи DMA (контроллера прямого доступа к памяти).
В микроконтроллер STM32F411RE встроено 2 DMA каждый из которых является
8 поточным FIFO (по типу очереди, первый байт данных пришёл и первый же ушёл).
DMA поддерживает циклическое управление буфером,
т.е. пока половина буфера наполняется со второй (уже полностью заполненной)
можно производить какие-либо действия.

Каждый поток связан с запросом DMA, который можно выбрать из 8 возможных
запросов канала. Выбор управляется битами CHSEL[2:0] в DMA_SxCR регистр. +
Только DMA2 имеет возможность записывать с ADC1 данные в память и только
по каналу 0. Поэтому дальше будет опираться на ADC1 и DMA2.

.Канал 0
image::DMA_DMA2 и ADC1.png[]

.Расположение в памяти встроенных DMA
image::Область памяти DMA.png[]

.Подача тактирования на DMA по шине AHB1
image::Тактирование DMA2.png[]

Бит 22 DMA2EN: подача системного тактирования на DMA2

- 0: DMA2 выключить
- *1: DMA2 включить*

Помимо DMA также тактирование необходимо подать и АЦП.

.Подача тактирования на ADC по шине APB2
image::Тактирование на ADC.png[]

Бит 8 ADC1EN: Тактирование ADC1

- 0: ADC1 выключить
- *1: ADC1 включить*

Необходимо настроить порты DMA и ADC.

.Регистр конфигурации потока DMA DMA_SxCR
image::DMA_SxCR.png[]

Биты 27:25 CHSEL[2:0]: Выбор канала.

- *000: канал 0*
- 001: канал 1
- 010: канал 2
- 011: канал 3
- 100: канал 4
- 101: канал 5
- 110: канал 6
- 111: канал 7

Эти биты защищены и могут быть записаны, только если EN равен «0».

Бит 19 CT: отвечает за выбор целевого буфера в режиме двойной буферизации

- *0: Текущая целевая память — 0 (адресуется указателем DMA_SxM0AR)*
- 1: Текущая целевая память — 1 (адресуется указателем DMA_SxM1AR)

Бит 18 DBM: Двойной буферный режим

- 0: Нет переключения буфера в конце передачи
- *1: Целевой объект памяти переключается в конце передачи DMA* +
Этот бит защищен и может быть записан, только если EN равен «0».

Биты 14:13 MSIZE[1:0]: Размер данных памяти +
Отвечает за то, куда будут сыпаться данные.
Т.к. процессор у нас 32-разрядный, то можно выделить 32 бита.

- 00: byte (8-bit)
- 01: half-word (16-bit)
- *10: word (32-bit)*
- 11: reserved

Эти биты защищены и могут быть записаны, только если EN равен «0».
В прямом режиме MSIZE принудительно устанавливается аппаратно на то же значение,
что и PSIZE, как только бит EN = «1».

Биты 12:11 PSIZE[1:0]: Размер периферийных данных +
Т.к. регистр АЦП 32-разрядный, то имеет смысл в регистр DMA
(который тоже 32-разрядный) записывать 32-разрядное значение.

- 00: Byte (8-bit)
- 01: Half-word (16-bit)
- *10: Word (32-bit)*
- 11: reserved

Эти биты защищены и могут быть записаны, только если EN равен «0».

Бит 8 CIRC: Циклический режим
Этот бит устанавливается и сбрасывается программно и может быть сброшен аппаратно.

- 0: disabled
- *1: enabled*

Когда периферийное устройство является контроллером потока (бит PFCTRL = 1) и
поток включен (бит EN = 1), то этот бит аппаратно автоматически устанавливается
в 0. Он автоматически устанавливается аппаратно в 1, если бит DBM установлен,
как только поток включено (бит EN = 1).

Биты 7:6 DIR[1:0]: Направление передачи данных
Эти биты устанавливаются и очищаются программным обеспечением.

- *00: Из периферийного устройства в память*
- 01: Из памяти в периферию
- 10: Из памяти в память
- 11: Зарезервировано

Эти биты защищены и могут быть записаны, только если EN равен «0».

Бит 5 PFCTRL: Контроллер периферийного потока
Этот бит устанавливается и сбрасывается программно.

- 0: *DMA — это контроллер потока*
- 1: Периферийное устройство — это контроллер потока

Этот бит защищен и может быть записан, только если EN равен «0».
Когда выбран режим памяти в память (биты DIR[1:0]=10), этот бит
автоматически сбрасывается на 0 аппаратно.

Бит 0 EN: Включить поток / пометить поток как готовый при низком уровне чтения
Этот бит устанавливается и сбрасывается программно.

- 0:  disabled
- *1:  enabled*

Когда этот бит считывается как 0, программе разрешено программировать
конфигурацию и битовые регистры FIFO. +
Запрещена запись в другие поля регистра, когда бит EN читается как 1. +
Примечание.  +
Прежде чем установить бит EN в «1» для начала новой передачи, флаги событий,
соответствующие потокам в регистрах *DMA_LISR или DMA_HISR должны быть очищены*.

.Поток DMAx регистра адреса памяти 0 (DMA_SxM0AR) (x = 0..7)
image::DMA_SxM0AR.png[]
Адрес переменной со значениями хранится по адресу DMA_S0M0AR

.Регистр DMA_LISR
image::DMA_LISR.png[]


.Регистр DMA_HISR
image::DMA_HISR.png[]

Теперь сконфигурируем АЦП и DMA.

.Регистр управления АЦП 1 (ADC_CR1)
image::ADC_CR1.png[]

Биты 25:24 RES[1:0]: Разрядность АЦП

- *00: 12-bit*
- 01: 10-bit
- 10: 8-bit
- 11: 6-bit

Теперь необходимо настроить АЦП, чтобы оно работало в режиме DMA.
Для измерения используются инжекторные каналы.
Они позволяют одновременно измерять и складывать в 4 ячейки свои значения.

Бит 12 JDISCEN: включает/отключает одиночный режим инжектированных каналов
Этот бит устанавливается и очищается программно, чтобы включить/Выключит

- 0: одиночный режим инжектированных каналов отключён
- *1: одиночный режим инжектированных каналов включён*

Бит 10 JAUTO: автоматическое преобразование инжектированной группы каналов
Этот бит устанавливается и очищается программно для разрешения/запрета
автоматического преобразования группы после преобразования регулярной группы.

- *0: автоматическое преобразование инжектированной группы выкл.*
- 1: автоматическое преобразование инжектированной группы вкл.

Бит 8 SCAN: режим сканирования
Этот бит устанавливается и сбрасывается программным обеспечением
для включения/отключения режима сканирования.
В режиме сканирования входы, выбранные через регистры ADC_SQRx или ADC_JSQRx,
преобразуются.

- 0: режим сканирования отключен
- *1: режим сканирования включен*

Примечание. Прерывание EOC генерируется, если установлен бит EOCIE: +
– В конце каждой регулярной групповой последовательности, если бит EOCS сброшен в 0 +
– В конце каждого обычного преобразования канала, если бит EOCS установлен в 1  +
Примечание. Прерывание JEOC генерируется только в конце преобразования последнего
канала, если Бит JEOCIE установлен.

.Регистр управления ADC_CR2
image::ADC_CR2.png[]

Бит 30 SWSTART: Начать преобразование обычных каналов

- *0: Сбросить состояние*
- 1: Запускает преобразование обычных каналов* +
Примечание.  +
Этот бит можно установить, только если ADON = 1, в противном случае
преобразование не запускается.

Бит 22 JSWSTART: начать преобразования инжектированных каналов +
Этот бит устанавливается программно и очищается аппаратно,
как только начнется преобразование.

- 0: сброс состояния
- *1: запуск преобразования инжектированных каналов*

Примечание: этот бит может быть установлен только тогда, когда ADON = 1,
В противном случае преобразование не запускается.

Бит 10 EOCS: Конец выбора преобразования

- 0: Бит EOC устанавливается в конце каждой последовательности обычных
преобразований. Обнаружение переполнения включается, только если DMA=1.
- *1: Бит EOC устанавливается в конце каждого обычного преобразования.
Обнаружение переполнения включено.*

Бит 9 DDS: Выбор отключения DMA (для режима одиночного АЦП)

- 0: После последней передачи не выдается новый запрос DMA
(как настроено в контроллере DMA)
- *1: Запросы DMA выдаются до тех пор, пока данные конвертируются и DMA=1.*

Запросы могут продолжать генерироваться, если бит DDS установлен в 1.
Это позволяет настроить DMA в циклическом режиме с двойным буфером.

Бит 8 DMA: Режим прямого доступа к памяти (для режима одиночного АЦП)

- 0: режим DMA выключен
- 1: *режим DMA включен*

Бит 1 CONT: Непрерывное преобразование
Этот бит устанавливается и сбрасывается программно.
Если он установлен, преобразование происходит непрерывно, пока не будет очищен.

- 0: Одиночный режим преобразования
- *1: Непрерывный режим преобразования*

Бит 0 ADON: Аналого-цифровой преобразователь ВКЛ./ВЫКЛ.

- 0: Отключение преобразования АЦП и переход в режим отключения питания.
- *1: Включить АЦП*

Теперь необходимо настроить DMA.
Выше было показано, что ADC1 может использоваться на 0 канале. Но т.к. данный
регистр настраивается только при сброшенном EN, то сперва необходимо установить
EN = 0, а затем уже настраивать каналы.

.Регистр шага выборки АЦП 1 (ADC_SMPR1)
image::ADC_SMPR1.png[]

Биты 26:0 SMPx[2:0]: Выбор времени выборки канала x +
Эти биты записываются программным обеспечением для индивидуального выбора
времени дискретизации для каждого канала.
Во время цикла выборки, биты выбора канала должны оставаться неизменными.

- 000: 3 цикла
- 001: 15 циклов
- 010: 28 цикла
- 011: 56 цикла
- *100: 84 цикла*
- 101: 112 цикла
- 110: 144 цикла
- 111: 480 цикла

.Регистр инжекторной последовательности АЦП 1 (ADC_JSQR)
image::ADC_jSQR.png[]

Биты 21:20 JL[1:0]: длина введенной последовательности

- *00: 1 преобразование*
- 01: 2 преобразования
- 10: 3 преобразования
- 11: 4 преобразования

Биты 19:15 JSQ4 [4:0]: канал для 4-го преобразования.

Биты 14:10 JSQ3 [4:0]: канал для 3-го преобразования.

Биты 9:5 JSQ2 [4:0]: канал для 2-го преобразования.

Биты 4:0 JSQ1 [4:0]: канал для 1-го преобразования.

В случае, если требуется опрашивать число каналов меньше 4, то биты JSQ смещаются в сторону старших разрядов.

image::ADC_jSQR_Primechanie.png[]

.Поток DMAx регистра адреса периферии (DMA_SxPAR) (x = 0..7)
image::DMA_SxPAR.png[]

В регистр DMA_S0PAR пропишем регистр инжекторного канала ADC_JDR4,
чтобы данные из АЦП канала сразу же уходили в регистр DMA.

.Инжекторные данные АЦП (x = 1..4)
image::ADC_JDRx.png[]

.Поток DMAx номера регистра данных (DMA_SxNDTR) (x = 0..7)
image::DMA_SxNDTR.png[]

Биты 15:0 NDT[15:0]: Количество элементов данных для передачи
Количество элементов данных для передачи (от 0 до 65535). Этот регистр может
быть записан только когда поток отключен.
Когда поток включен, этот регистр доступен только для чтения, указывая
оставшиеся элементы данных, подлежащие передаче.
Этот регистр уменьшается после каждого прямого доступа к памяти.
После завершения передачи этот регистр может либо оставаться на нуле
(когда поток находится в нормальном режиме), либо автоматически перезагружаться
ранее запрограммированным значением в следующие случаи:
– когда поток настроен в циклическом режиме.
– когда поток снова включен, установив бит EN в «1».
Если значение этого регистра равно нулю, транзакция не может быть обслужена,
даже если поток включён.

В регистр DMA_S0NDTR запишем 1,
потому что за один раз DMA перекинет 32-битное число с АЦП.

.Регистр состояния АЦП (ADC_SR)
image::ADC_SR.png[]

Бит 1 EOC: Окончание конверсии обычного канала

- 0: Преобразование не завершено (EOCS=0) или
последовательность преобразований не завершена (EOCS=1).
- *1: Преобразование завершено (EOCS=0) или
завершена последовательность преобразований (EOCS=1).*

.Регистр обычных данных АЦП (ADC_DR)
image::ADC_DR.png[]

==== Порядок запуска ADC с подключённым к нему DMA:

. Подключить DMA к источнику тактирования – устанавливаем бит DMA2EN в
регистре RCC::AHB2ENR (DMA тактируется от шины AHB1).

. Подключить АЦП к источнику тактирования – устанавливаем бит ADC1EN в
регистре RCC::APB2ENR (АЦП тактируется от шины APB2).

. Сконфигурировать порты АЦП и DMA.
Определиться по каким каналам будут проводиться измерения,
затем соответствующие выводы портов настроить для работы в аналоговом режиме. +
TBD: т.к. потенциометр находится на плате расширения и привязан к РА0,
то необходимо подать тактирование на порт А: +
RCC::AHB1ENR::GPIOAEN::Enable::Set(), +
А затем назначить данный пин как аналоговый: +
GPIOA::MODER::MODER0::Analog::Set().


. Отключить поток, сбросив бит EN в регистре DMA_SxCR, затем прочитать
этот бит, чтобы убедиться в отсутствии текущей потоковой операции.
Когда бит EN читается как 0, это означает, что поток готов к настройке.

. Сконфигурировать АЦП и DMA.

- Установить разрядность в регистре ADC::CR1
- Установить режим непрерывного преобразование в регистре ADC::CR1
(биты CONT и EOCS установить в нужное значение)
- установить количество измерений в регистре ADC1::SQR1 бит L
- Выбрать канал для первого преобразования в регистре ADC1::SQR3 биты SQ1
- Установить скорость дискретизации в регистре SMPRx для нужного канала

. Установить адрес регистра периферийного порта в регистре DMA_SxPAR.
Данные будут перемещаться на этот адрес с периферийного порта после
периферийного события.
В регистр DMA_S0PAR пропишем регистр инжекторного канала ADC_JDR4.

. Установить адрес памяти в регистре DMA_SxM0AR (и в регистре DMA_SxM1AR).
Данные будут записываться или считываться из этой памяти после периферийного
события.

. Настроить общее количество элементов данных,
которые будут переданы в DMA_SxNDTR регистр.

. Выбрать канал DMA (запрос), используя CHSEL[2:0] в регистре DMA_SxCR.

. Настроить использование FIFO
(включение или отключение, пороговое значение при передаче и приеме).

. Активируйте поток, установив бит EN в регистре DMA_SxCR. +
Как только поток включен, он может обслуживать любой запрос DMA от
периферийного устройства подключённого к потоку. +
Чтобы выключить периферийное устройство, подключенное к потоку DMA
запроса, необходимо сначала отключить поток DMA для
к которому подключено периферийное устройство, то ждать бит EN = 0.
Только после этого периферийное устройство можно безопасно отключить. +
Когда режим DMA включен (бит DMA установлен в 1 в регистре ADC_CR2),
после каждого преобразование обычного канала, генерируется запрос DMA.
Это позволяет передавать преобразованные данные из регистра ADC_DR в место
назначения.

. Включить АЦП. Это делается установкой бита ADON в регистре ADC::CR2.

. Запустить АЦП на преобразование установкой бита SWSTART в регистре
ADC::CR2 для регулярных каналов

=== Расчёт температуры
Температура, согласно заданию, считает по следующей формуле:
[stem]
++++
T = At + code * Bt + code^2 * Ct ,
++++

где At,Bt,Ct - градуировочные коэффициенты; +
code – код АЦП; +
T - температура

Температура на ФЭУ изменяется от -50 до +30 градусов Цельсия.
По техническим причинам не получается охлаждать ФЭУ ниже -50 градусов Цельсия,
а в помещении, отведённом под эксплуатацию метрологического комплекса даже в
самый жаркий летний день температура не подымается выше +30 градусов Цельсия. +

Для терморезистора pt100 представлена следующая зависимость взятая с даташита на
терморезистор c сайта:
https://www.2150692.ru/tovary/sensors/thermal/product/view/25/432

.Функция зависимости сопротивления от температуры
image::Терморезистор_Функция.png[]

Определим нелинейность данной функции и подберём градуировочные коэффициенты
в программе: https://www.wolframalpha.com/.

.Расчёт коэффициентов для терморезистора
image::Расчёт коэффициентов для терморезистора.png[]

Итого получили градуировочные коэффициенты: +
At = -246,584; +
Bt =  2,37383; +
Ct = 0,000921853; +
Данные величины буду храниться в памяти микроконтроллера типом float
(знаковое 32 байтовое вещественное число), т.к. данная разрядная сетка в 4 байта
(32 бита) позволяет хранить такие числа без существенного искажения.

.Пример искажения числа при хранении его типом float
image::Пример искажения числа при хранении его типом float.png[]

Т.к. наше АЦП явлется 12-разрядным, то 2^12 = 4096, т.е. измеряемый диапазон
температуры (code) составляет от 0 до 4095 отсчётов АЦП.
Температура на ФЭУ изменяется от -50 до +30 градусов Цельсия. +
Посчитав (30-(-50)) / 4096 = 0,02 получим, что 0,02 градуса приходится на один
отсчёт АЦП, т.е. погрешность АЦП на данном температурном участке составляет
0,02 градуса Цельсия. +
С учётом градуировочных коэффициентов при расчёте температуры, получим
следующую нелинейность терморезистора.

.Квадратичная зависимость термосопротивления
image::Квадратичная зависимсоть термосопротивления.png[]

Существуют специальные методы обработки сигналов, позволяющие увеличить разрешение
измерений. С помощью метода называемого *оверсемплинг* и *децимация*.
Данные методы используют большее число выборок сигнала, тем самым увеличив частоту
его дискретизации.
Для каждого дополнительного бита разрешения требуется увеличение частоты
дискретизации в 4 раза.
Большее количество выборок нужно для лучшего представления входного аналогового
сигнала при усреднении.
Обычный смысл усреднения заключается в сложении *m* выборок сигнала и
делении полученного результата на *m*. Это так называемое нормальное усреднение.
Очень часто для этого также используется метод скользящего среднего.
Он заключается в усреднении выборок сигнала внутри циклической очереди.
В этом случае каждая усредненная выборка сигнала будет представлена несколькими
самыми последними выборками. Что будет давать небольшую временную задержку.
Методы *оверсемплинга* и *децимации*  работают только при наличии Гауссовского шума,
который отличается широкой полосой частот и равномерным распределением энергии по
всей полосе. Метод *оверсемплинга* и *децимации* будет работать, если амплитуда
шума достаточна для переключения преобразования АЦП.

Погрешность АЦП = 0,02 градуса Цельсия. +
Погрешность формулы = 0,03 градуса Цельсия. +
Итого: 0,02 + 0,03 = 0,05 градусов Цельсия составляет погрешность измерения,
это позволяет измерять температуру с точностью до ±0,1 градус Цельсия.
Согласно ТЗ нас это устраивает.

=== ОСРВ
Согласно заданию необходимо проводить измерения ежесекундно.
Для этих целей хорошо использовать операционную систему реального времени (ОСРВ).
ОСРВ поможет создать несколько разнородных задач, выполнение которых будет
происходить в заданные периоды времени. +
Итак, составим задачи для ОСРВ:

. Измерение температуры при помощи АЦП и сохранение полученных
данных при помощи DMA в регистры памяти микроконтроллера. +
Данная задача осуществляет считывание с терморезистора значение в виде кода АЦП,
считает по формуле (переводит в температуру) и посчитанное значение температуры
заносит в память микроконтроллера, где эти данные становятся всем доступные.
. Ежесекундное измерение расхода воды в кране. +
Данная задача запускает таймер в режиме захвата,
который измеряет количество импульсов, пришедших за 1000 миллисекунд.
. Задача регулирования силы тока при помощи широтно-импульсной модуляции (ШИМ). +
Ежесекундно данная задача берёт данные (текущая температура на ФЭУ, рассчитанная АЦП и
скорость потока воды с расходомера). Данная задача осуществляет расчёт CCR, т.е.
изменяя коэффициент заполнения сигнала, на пин будет подаваться напряжение от 0 В до
опорного 3,3 В. Т.о. плавное изменение CCR может в случае отсутсвия воды и
повышения температуры на элементах Пельтье отключить элементы Пельтье, выставив CCR = 0.

=== Измерение расхода воды
Для измерения расхода воды используется датчик SEN02141B. Однако, для имитации
работы расходомера используется плата STM32F411RE.
Для платы STM32F411RE потребуется таймер в режиме захвата.

Буду использовать первый канал таймера TIM3.
Поэтому после подачи тактирования на пины GPIOB (RCC::AHB1ENR::GPIOBEN::Enable::Set())
назначу пин PB4 альтернативным (GPIOB::MODER::MODER4::Alternate::Set()).

.Вывод PB4
image::OutputPB4.png[]

.Альтернативная функция PB4
image::AlternatePB4.png[]

Альтернативная функция для таймера TIM3 канала 1 на пине PB4
настраивается следующим образом: GPIOB::AFRL::AFRL4::Af2::Set(), +
где GPIOB - регистор PB, +
AFRL - потому что AF02 находится в первой пполовине (до AF08), +
AFRL4 - для 4 канала регистра PB.

.Включение таймера TIM3
image::TIM3_RCC_APB2ENR.png[]
Бит 0 TIM3EN: таймер TIM3 включены

- 0: Таймер TIM3 отключён +
- *1: Таймер TIM3 включён* +

.Сброс таймера TIM3
image::TIM3_RCC_APB2RSTR.png[]
Бит 0 TIM3RST: сброс TIM3

- 0: не сбрасывает TIM3
- *1: сбрасывает TIM3*

Таймер TIM3 канал 1 должен работать в режиме захвата,
т.е. данный вывод будет фиксировать изменение логического уровня сигнала,
приходящего на пин PB4.

.TIM3_CCMR1
image::TIM3_CCMR1.png[]
Биты 1:0 CC1S: Захват/Сравнение 1 выбор +
Это битовое поле определяет направление канала (вход/выход),
а также используемый вход.

- 00: канал CC1 настроен как выход
- *01: канал CC1 настроен как вход, IC1 отображается на TI1*
- 10: канал CC1 настроен как вход, IC1 отображается на TI2
- 11: Канал CC1 настроен как вход, IC1 отображается на TRC.
Этот режим работает,
только если вход внутреннего триггера выбирается через бит TS (регистр TIMx_SMCR). +
Примечание. Биты CC1S доступны для записи,
только когда канал выключен (CC1E = «0» в TIM3_CCER).

Биты 7:4 IC1F[3:0]: входной фильтр захвата +
Это битовое поле определяет частоту,
используемую для выборки входного сигнала TIM3,
и длину применяемого цифрового фильтра.
Цифровой фильтр состоит из счетчика событий,
в котором требуется N последовательных событий, чтобы
проверить переход на выходе:

- 0000: Нет фильтра, выборка выполняется в fDTS
- *0001: fSAMPLING=fCK_INT, N=2*
- 0010: fSAMPLING=fCK_INT, N=4
- 0011: fSAMPLING=fCK_INT, N=8
- 0100: fSAMPLING=fDTS/2, N=6
- 0101: fSAMPLING=fDTS/2, N=8
- 0110: fSAMPLING=fDTS/4, N=6
- 0111: fSAMPLING=fDTS/4, N=8
- 1000: fSAMPLING=fDTS/8, N=6
- 1001: fSAMPLING=fDTS/8, N=8
- 1010: fSAMPLING=fDTS/16, N=5
- 1011: fSAMPLING=fDTS/16, N=6
- 1100: fSAMPLING=fDTS/16, N=8
- 1101: fSAMPLING=fDTS/32, N=5
- 1110: fSAMPLING=fDTS/32, N=6
- 1111: fSAMPLING=fDTS/32, N=8

.Регистр захвата/сравнения таймера TIM3
image::TIM3_CCER.png[]
Бит 0 CC1E: Захват/Сравнение
Канал CC1 настроен как вход:
Этот бит определяет,
действительно ли можно выполнить захват значения счетчика на входе.

- 0: Захват отключен
- *1: Захват включен*

Бит 1 CC1P: захват/сравнение полярности выхода +
Канал CC1 настроен как вход: +
Биты CC1NP/CC1P выбирают активную полярность TI1FP1 и TI2FP1 для запуска или захвата.

- 00: *неинвертированный/нарастающий фронт +
Схема чувствительна к переднему фронту TIxFP1*.
- 01: инвертированный/задний фронт +
Схема чувствительна к заднему фронту TIxFP1
- 10: зарезервировано, не используйте эту конфигурацию.
- 11: не перевернутый/оба края

.Регистр TIM3_DIER
image::TIM3_DIER.png[]

Бит 1 CC1IE: разрешение прерывания захвата/сравнения

- 0: прерывание CC1 отключено
- *1: прерывание CC1 разрешено*

После того как произошёл захват формируется событие захвата,
которое устанавливает соответствующий флаг в регистре TIM3_EGR.
Это может привести к генерации прерывания, если оно разрешено в регистре DIER.

.Позиции глобальных прерываний относительно системного таймера
image::NVIC.png[]

Теперь необходимо резрешить глобальное прерывание в регистре NVIC.
Для этого зная позицию *29* TIM3,
необходимо в регистре NVIC поставить соответствуюющий бит:  NVIC::ISER0::Write(1U << 29U), +
где ISER0 - т.к. ISER 32 разрядный, т.е. ISER0 - отвечает за первые 32 позиции.
Таймер находится на 29 позиции, поэтому ISER0 подходит.

.Регистр SR таймера TIM3
image::TIM3_SR.png[]

Бит 0 UIF: обновление флага прерывания +
- *0: обновление не произошло* +
- 1: Ожидание прерывания обновления

Также необходимо настроить делитель частоты в регистре *TIM3::PSC*.

=== Регулирование силы тока ШИМом

Согласно заданию, необходимо регулировать силу тока, протекающую по элементам
Пельтье. Для плавного регулирования силы тока хорошо использовать
широтно-импульсную модуляцию (ШИМ). Для регулирования силы тока при помощи ШИМ
используются такие параметры ШИМа как ARR - максимальное число импульсов и
CCR - отвечающий за коэффициент заполнения. +
В STM32F411RE буду использовать ШИМ-таймер - таймер общего назначения (TIM3).

Буду использовать второй канал таймера TIM3, т.к. данный канал связан со светодиодом,
это позволит наглядно увидеть изменение ШИМ-сигнала, когда светодио будет светиться ярко
или тускло.
Поэтому после подачи тактирования на пины GPIOC (RCC::AHB1ENR::GPIOCEN::Enable::Set())
назначу пин PA7 альтернативным (GPIOC::MODER::MODER7::Alternate::Set()).

.Вывод PA11
image::OutputPC7.png[]

.Альтернативная функция PС7
image::AlternatePC7.png[]

Альтернативная функция для таймера TIM3 канала 1 на пине PB4
настраивается следующим образом:   GPIOC::AFRL::AFRL7::Af2::Set(), +
где GPIOС - регистор PС, +
AFRL - потому что AF02 находится в первой пполовине (до AF08), +
AFRL7 - для 7 канала регистра PС.

Настроим таймер на выход.

.Регистр CCMR1 таймера TIM3
image::TIM3_CCMR_PWM.png[]

Биты 14:12 OC2M: Режим сравнения выходов 2

- 001: Установите канал 2 на активный уровень при совпадении.
Сигнал OC2REF принудительно устанавливается на высокий уровень, когда счетчик
TIMx_CNT соответствует регистру захвата/сравнения 2 (TIMx_CCR1).
- 010: Установить канал 2 на неактивный уровень при совпадении.
Сигнал OC1REF принудительно устанавливается на низкий уровень, когда
счетчик TIMx_CNT соответствует регистру захвата/сравнения 2 (TIMx_CCR1).
- 011: Toggle — OC2REF переключается, когда TIMx_CNT=TIMx_CCR1.
- 100: Принудительно неактивный уровень — OC2REF
принудительно устанавливается на низкий уровень.
- 101: Принудительный активный уровень — OC2REF
принудительно устанавливается на высокий уровень.
- *110: ШИМ-режим* 1 — при восходящем счете канал 2 активен до тех пор,
пока TIMx_CNT<TIMx_CCR1 остальное неактивно.
При обратном счете канал 2 неактивен (OC2REF=‘0) до тех пор, пока
TIMx_CNT>TIMx_CCR1 еще активен (OC1REF=1).
- 111: ШИМ-режим 2 — при восходящем счете канал 2 неактивен до тех пор,
пока TIMx_CNT<TIMx_CCR1 остальное активно.
При обратном счете канал 2 активен до тех пор, пока TIMx_CNT>TIMx_CCR1, иначе неактивный.

Режим широтно-импульсной модуляции (ШИМ) позволяет генерировать сигнал с частотой,
определяемой значение регистра TIM3_ARR и рабочий цикл,
определяемый значением регистра TIM3_CCR2.

TIM3_ARR – регистр автоматической перезагрузки,
счётчик считает от 0 до TIM3_ARR, или наоборот в зависимости от направления счёта,
изменяя это значение, можно изменять частоту ШИМ-сигнала.

TIM3_CCR2[TIM3 – номер таймера, CCR2 – номер канала] –
определяет коэффициент заполнения ШИМ.

.Регистр TIM3_CCER
image::TIM1_CCER.png[]

Бит 4 CC2E: выход захвата/сравнения 1 включен.
*Канал CC2 настроен как выход:*

- 0: Выкл. — CC2 не активен
- *1: Вкл. - сигнал CC2 выводится на выходной контакт GPIOC7*

Сила тока рассчитывается по формуле:
[stem]
++++
I = temperature * Ai * duty ,
++++
где Ai - коэффициент зависимости; +
duty - коэффициент заполнения в %,;
temperature - температура, заданная потенциометром.

Полагаем, что температура изменяется от -66 до +33 градусов Цельсия+
Также полагаем, что ток в цепи изменяется от 0 до 11 Ампер +
Коэффициент заполнения изменяется от 0 до 100%. +
Сперва найдём ток по линейному закону,
который будет соответствовать изменению температуры:

image::I (temperature).png[]

Затем найдём коэффициент заполнения, эквивалентный силе тока:

image::S (I).png[]

Тогда получим, что Ai = 7,333 +
duty = 0,111

== Глава 2. Дизайн программы
Проанализировав требования, составим дизайн программы, обозначим классы и их методы.
*ITread*  - класс задач ОСРВ.
Всего будет 3 задачи: +
*TemperatureTask* - задача, которая получает code с АЦП раз в секунду. +
*FlowTask* - задача, которая получает code с расхода (таймера TIM3) раз в секунду. +
*CurrentPowerRegulationTask* - подаёт на вывод напряжение раз в секунду. +

В архитектуре присутствуют следующие классы: +
*ADC* - получает значение с АЦП. +
*Resistor* - пересчитывает значение code АЦП в сопротивление. +
*Temperature* - переводит сопротивление на резисторе в температуру. +

*TimerCCR* - считает количество пришедших импульсов. +
*Flowmeter* - измеряет количество передних фронтов, приходящего сигнала. +
*WaterConsumtion* - переводит количество пришедших передних фронтов в литры/мин. +

*CurrentControler* - по текущей температуре, а также по скорости потока
расчитывает силу тока, подаваемую на элементы Пельтье. +
*PWM* - по силе тока раcсчитывает коэффициент заполнения CCR.

В архитектуре присутствуют интерфейсы: +
*IMeasureParameter* - который имеет переопределяющийся метод *Calculated*.
 Данный метод умеет только расчитывать значения. +
*IDataSource* - Запрашивает данные.

[plantuml]

----
class ITread
{
  + Execute(): void
}

class TemperatureTask
{
  - _parameter: IMeasureParameter
  + TemperatureTask(parameter: IMeasureParameter)
}

class FlowTask
{
  - _parameter: IMeasureParameter
  + FlowTask(parameter: IMeasureParameter)
}

class CurrentPowerRegulationTask
{
  - _parameter: IMeasureParameter
  + CurrentPowerRegulationTask(parameter: IMeasureParameter)
}

ITread <|-- TemperatureTask
ITread <|-- FlowTask
ITread <|-- CurrentPowerRegulationTask

class PWM
{
  - _parameters: IDataSource
  - {static} k: float
  - {static} b: float
  + PWM(parameters: IDataSource)
}

class CurrentControler
{
  - _flowRate: IDataSource
  - _temp: IDataSource
  - Ai: float
  - duty: float
  + MovingAverage(): float
  + CurrentControler(flowRate: IDataSource)
}

abstract class IMeasureParameter
{
   + {abstract} Calculate (): float
}

class WaterConsumption
{
  - {static} s: int16_t
  - {static} R: float
  - _flowConsumption: float
  - _dataSource: IMeasureParameter
  + Flow(dataSource: IMeasureParameter)
}

class Temperature
{
  - {static} At: float
  - {static} Bt: float
  - {static} Ct: float
  - _temp: float
  - _resistor: IDataSource
  + Temperature(resistor: IDataSource)
}

abstract class IDataSource
{
  + {abstract} GetData(): float
}

class Flowmeter
{
  - _dataSource: IDataSource
  - oldValue: float
  - _currentFlow: float
  + Flowmeter(dataSource: IDataSource)
}

class TimerCCR
{
  - counter: uint32_t
  + InterruptProcessing():void
}

class Resistor
{
  - {static} k: float
  - {static} b: float
  - _code: IDataSource&
  + Resistor(code: IDataSource)
}

class ADC
{
  - code: uint32_t
  + ADC()
  + Start():void
}

class DMA<TDmaConfig>
{
  + {static} Configure(variableAddress: uint32_t ): void
  + {static} Disable(): void
}

class ConfigDMA<typename TDmaChannelConfigRegValue, + typename TDmaDataReceivingReg, typename TDataSendingReg, typename TDataCountReg >
{

}

TemperatureTask o-- IMeasureParameter
IMeasureParameter <|-- Temperature
IDataSource <|-- Temperature
IDataSource <|-- Resistor
IDataSource <|-- ADC

FlowTask o-- IMeasureParameter
IMeasureParameter <|-- WaterConsumption
IDataSource <|-- WaterConsumption
IDataSource <|-- Flowmeter
IMeasureParameter <|-- Flowmeter
IDataSource <|-- TimerCCR

CurrentPowerRegulationTask o-- IMeasureParameter
PWM o-- IDataSource
IMeasureParameter <|-- PWM
IDataSource <|-- CurrentControler


ADC <-- DMA
DMA .. ConfigDMA

----





